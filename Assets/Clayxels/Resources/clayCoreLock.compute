#pragma kernel compute0
#pragma kernel compute2
#pragma kernel compute4
#pragma kernel compute6
#pragma kernel cache4
#pragma kernel cache6
#pragma kernel genPointCloud
#pragma kernel clearChunkData
#pragma kernel debugDisplayGridPoints
#pragma kernel genMesh
#include"claySDF.compute"
RWStructuredBuffer<int2> chunkCell;RWStructuredBuffer<int4> chunkOutPoints;RWStructuredBuffer<float3> chunkOutData;RWStructuredBuffer<int4> solidsFilterIn,solidsFilterOut;StructuredBuffer<int> triangleConnectionTable;
#if DEBUGGRIDPOINTS
RWStructuredBuffer<float3> debugGridOutPoints;int debugGridSideCount;
#endif
StructuredBuffer<float3> solidsPos;StructuredBuffer<float4> solidsRot;StructuredBuffer<float3> solidsScale;StructuredBuffer<float> solidsBlend;StructuredBuffer<int> solidsType;StructuredBuffer<float3> solidsColor;StructuredBuffer<float4> solidsAttrs;RWStructuredBuffer<int3> meshOutIndices;RWStructuredBuffer<float3> meshOutPoints;RWStructuredBuffer<float4> meshOutColors;uint numSolids=0;float chunkSize=20.;float3 chunkCenter=float3(0.,0.,0.);int outMeshIndexOffset=0;float surfaceBoundaryThreshold=1.;static const int3 localGridCellCoords[8]={int3(0,0,0),int3(1,0,0),int3(1,1,0),int3(0,1,0),int3(0,0,1),int3(1,0,1),int3(1,1,1),int3(0,1,1)};static const float3 vertexOffset[8]={float3(0,0,0),float3(1,0,0),float3(1,1,0),float3(0,1,0),float3(0,0,1),float3(1,0,1),float3(1,1,1),float3(0,1,1)};static const int2 edgeConnection[12]={int2(0,1),int2(1,2),int2(2,3),int2(3,0),int2(4,5),int2(5,6),int2(6,7),int2(7,4),int2(0,4),int2(1,5),int2(2,6),int2(3,7)};static const float3 edgeDirection[12]={float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f)},cardinalCellOffset[8]={float3(-1,-1,-1),float3(1,-1,-1),float3(1,1,-1),float3(-1,1,-1),float3(-1,-1,1),float3(1,-1,1),float3(1,1,1),float3(-1,1,1)};static const int cubeEdgeFlags[]={0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0};int f(int y,int f,int z,int c){return y+c*(f+c*z);}uint f(float3 f){uint c=uint(f.x*255)+uint(f.y*255)*256+uint(f.z*255)*256*256;return c;}float f(float f,float i,float c){float s=max(c-abs(f-i),0.);return min(f,i)-s*s*.25f/c;}float c(float f,float i,float c){float s=abs(c),M=max(s-abs(-f-i),0.);return max(-f,i)+M*M*.25/s;}bool c(int4 f,int c){if(c>63)return false;uint s=uint(c)/32;int i=f[s],M=c-32*s;if(i>>M&1)return true;return false;}void f(uint f,inout int4 c){uint s=f/32;int i=c[s],z=f-32*s;i=i&~(1<<z);if(s==0)c.x=i;else if(s==1)c.y=i;else if(s==2)c.z=i;else if(s==3)c.w=i;}bool c(int c){return c>>0&1;}float c(float3 i,float y,int x,int4 s,float r){float z=1e+10;int k=0;for(uint u=0;u<numSolids;++u){if(!c(s,u)){continue;}float M=solidsBlend[u];float4 t=solidsAttrs[u];float S=computeClayDistanceFunction(solidsType[u],i,solidsPos[u],solidsRot[u],solidsScale[u],t);if(!c(t.w)){if(M==0.)z=min(S,z);else if(M>0.)z=f(S,z,M);else z=c(S,z,M);}if(S>r)f(u,s);r-=abs(M);}if(abs(z)<=y)solidsFilterOut[x]=s;return z;}float f(float3 i,float y,out int z,out float3 s,int4 x){float r=1e+10;s=float3(1.,1.,1.);for(uint e=0;e<numSolids;++e){if(!c(x,e)){continue;}float M=solidsBlend[e];float3 u=solidsColor[e];float4 t=solidsAttrs[e];float S=computeClayDistanceFunction(solidsType[e],i,solidsPos[e],solidsRot[e],solidsScale[e],t);if(S<r)z=e;bool k=c(t.w);if(M==0.){float D=clamp((r-S)/(y*2.),0.,1.);s=lerp(s,u,D);if(!k)r=min(S,r);}else if(M>0.){float D=clamp(.5+.5*(S-r)/M,0.,1.);s=lerp(u,s,D);if(!k)r=f(S,r,M);}else{float D=clamp(.5+.5*(-S-r)/M,0.,1.);s=lerp(u,s,D);if(!k)r=c(S,r,M);if(D<.5)z=e;}}return r;}float s(float3 i,float y,out int z,out float3 s,int4 S){float r=1e+10;s=float3(1.,1.,1.);int x=0;for(uint e=0;e<numSolids;++e){if(!c(S,e)){continue;}x+=1;float M=solidsBlend[e];float3 k=solidsColor[e];float u=computeClayDistanceFunction(solidsType[e],i,solidsPos[e],solidsRot[e],solidsScale[e],solidsAttrs[e]);if(u<r)z=e;if(M==0.)r=min(u,r);else if(M>0.)r=f(u,r,M);else r=c(u,r,M);}float M=float(x-1)/float(numSolids-1);s=lerp(float3(0.,0.,1.),float3(1.,0.,0.),M);return r;}float3 s(int f){int c=(f&255)>>0,i=(f&65280)>>8,s=(f&16711680)>>16;return float3(c/255.,i/255.,s/255.);}bool r(int3 f){if(f.x<0)return true;if(f.x>255)return true;if(f.y<0)return true;if(f.y>255)return true;if(f.z<0)return true;if(f.z>255)return true;return false;}void r(float3 i,float y,int z,int4 s,float M){float r=y*.5,D=r*.5,x=chunkSize/z,u=chunkSize*.5;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e],t=float3(i.x+D*k.x,i.y+D*k.y,i.z+D*k.z),S=float3(round((t.x+u-D)/x),round((t.y+u-D)/x),round((t.z+u-D)/x));int n=f(S.x,S.y,S.z,z);float d=c(t+chunkCenter,r,n,s,M+r);if(abs(d)<r*surfaceBoundaryThreshold)chunkCell[n]=int2(0,1);}}void i(float3 f,float c,int i,int4 s,float M){float z=c*.5,u=z*.5;float3 S;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e];S.x=f.x+u*k.x;S.y=f.y+u*k.y;S.z=f.z+u*k.z;r(S,z,i,s,M);}}float i(int4 f){float s=0.;for(uint i=0;i<numSolids;++i){if(!c(f,i)){continue;}s+=abs(solidsBlend[i]);}return s;}[numthreads(4,4,4)]void compute0(int3 s:SV_DispatchThreadID){float z=chunkSize/4,r=z*.5;float3 u=float3(z*s.x-z-r,z*s.y-z-r,z*s.z-z-r);int e=f(s.x,s.y,s.z,4);int4 M=int4(-1,-1,-1,-1);float x=i(M),S=c(u+chunkCenter,z,e,M,x+z);if(abs(S)<z*surfaceBoundaryThreshold)chunkCell[e]=int2(1,0),solidsFilterIn[e]=solidsFilterOut[e],solidsFilterOut[e]=int4(-1,-1,-1,-1);}float3 i(int3 f,float i){float s=i*.5,z=chunkSize*.5;float3 c=float3(i*f.x-z,i*f.y-z,i*f.z-z)+s;return c;}[numthreads(4,4,4)]void compute2(int3 s:SV_DispatchThreadID){int e=f(s.x,s.y,s.z,4);if(chunkCell[e].x==1){chunkCell[e]=int2(0,0);float z=chunkSize/4;float3 c=i(s,z);int4 M=solidsFilterIn[e];float r=i(M);i(c,z,16,M,r);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void compute4(int3 s:SV_DispatchThreadID){int e=f(s.x,s.y,s.z,16);if(chunkCell[e].x==1){chunkCell[e]=int2(0,0);float z=chunkSize/16;float3 c=i(s,z);int4 M=solidsFilterIn[e];float r=i(M);i(c,z,64,M,r);}}void i(float3 i,float c,int4 M){float z=c*.5,r=z*.5,D=chunkSize/256,u=chunkSize*.5;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e],x=float3(i.x+r*k.x,i.y+r*k.y,i.z+r*k.z),S=float3(round((x.x+u-r)/D),round((x.y+u-r)/D),round((x.z+u-r)/D));int y=0;float3 t=float3(1.,1.,1.);
#if DEBUGFILTERS
float d=s(x+chunkCenter,z,y,t,M);
#else
float n=f(x+chunkCenter,z,y,t,M);
#endif
if(abs(n)<c*surfaceBoundaryThreshold){int m=f(S.x,S.y,S.z,256);chunkOutData[m]=float3(n,f(t),y+1);}}}void r(float3 f,float c,int4 s){float z=c*.5,r=z*.5;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e],M=float3(f.x+r*k.x,f.y+r*k.y,f.z+r*k.z);i(M,z,s);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void compute6(int3 s:SV_DispatchThreadID){int e=f(s.x,s.y,s.z,64);if(chunkCell[e].x==1){float z=chunkSize/64;float3 c=i(s,z);int4 M=solidsFilterIn[e];r(c,z,M);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void cache6(int3 i:SV_DispatchThreadID){int e=f(i.x,i.y,i.z,64);if(chunkCell[e].y==1)chunkCell[e]=int2(1,0),solidsFilterIn[e]=solidsFilterOut[e],solidsFilterOut[e]=int4(-1,-1,-1,-1);}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void cache4(int3 i:SV_DispatchThreadID){int e=f(i.x,i.y,i.z,16);if(chunkCell[e].y==1)chunkCell[e]=int2(1,0),solidsFilterIn[e]=solidsFilterOut[e],solidsFilterOut[e]=int4(-1,-1,-1,-1);}void r(float3 i,float c){float s=c*.5,z=s*.5,M=chunkSize/256,r=chunkSize*.5;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e],u=float3(i.x+z*k.x,i.y+z*k.y,i.z+z*k.z);int3 S=float3(round((u.x+r-z)/M),round((u.y+r-z)/M),round((u.z+r-z)/M));int x=f(S.x,S.y,S.z,256);chunkOutData[x].z=0.;}}void s(float3 f,float c){float i=c*.5,z=i*.5;for(uint e=0;e<8;++e){float3 s=cardinalCellOffset[e],M=float3(f.x+z*s.x,f.y+z*s.y,f.z+z*s.z);r(M,i);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void clearChunkData(int3 c:SV_DispatchThreadID){int e=f(c.x,c.y,c.z,64);if(chunkCell[e].x==1){chunkCell[e].x=0;float z=chunkSize/64;float3 x=i(c,z);s(x,z);}}float d(float f,float c){float s=c-f,i=.5;if(s!=0.)i=f/s;return i;}float2 d(float2 f){float2 s=f.xy>=0.?1.:-1.,i=(1.-abs(f.yx))*s;return i;}float t(float2 f){int s=2048;float c=floor(f.x*(s-1)),i=floor(f.y*(s-1)),z=c*s+i;return z;}float m(float3 f){f/=abs(f.x)+abs(f.y)+abs(f.z);f.xy=f.z>=0.?f.xy:d(f.xy);f.xy=f.xy*.5+.5;float s=t(f.xy);return s;}int c(uint f,uint c,uint z,uint s){int e=f<<24|c<<16|z<<8|s;return e;}float u(float3 f){float s=dot(round(f*255),float3(65536,256,1));return s;}void m(int3 i,float s){int e=f(i.x,i.y,i.z,256);float3 z=chunkOutData[e];if(z.z==0.){return;}float t[8];int r=0;for(int M=0;M<8;++M){int3 S=i+localGridCellCoords[M];int x=f(S.x,S.y,S.z,256);float3 k=chunkOutData[x];if(k.z==0.){return;}t[M]=k.x;if(k.x<=0.)r|=1<<M;}int k=cubeEdgeFlags[r];if(k==0){return;}float3 x=i;int y=r*16,l[3]={triangleConnectionTable[y+3],triangleConnectionTable[y+4],triangleConnectionTable[y+5]};float3 S=float3(0,0,0),n[3];int D;for(D=0;D<3;++D){int g=l[D];float a=t[edgeConnection[g].x],o=t[edgeConnection[g].y],w=d(a,o);float3 v=x+(vertexOffset[edgeConnection[g].x]-w*edgeDirection[g])*s;n[D]=v;S+=v;}float3 a=cross(n[2]-n[0],n[1]-n[0]);if(abs(a.x+a.y+a.z)>0.){S/=3.;float3 g=(S-x)/s;uint o=uint(u(g));float v=m(normalize(a));int w=z.y,h=z.z,C=chunkOutPoints.IncrementCounter();chunkOutPoints[C]=int4(c(i.x,i.y,i.z,h),o,v,w);}}void t(float3 f,float c){float i=c*.5,z=i*.5,M=chunkSize/256,s=chunkSize*.5;for(uint e=0;e<8;++e){float3 k=cardinalCellOffset[e],S=float3(f.x+z*k.x,f.y+z*k.y,f.z+z*k.z);int3 x=float3(round((S.x+s-z)/M),round((S.y+s-z)/M),round((S.z+s-z)/M));if(x.y<255)m(x,i);}}void u(float3 f,float c){float i=c*.5,z=i*.5;for(uint e=0;e<8;++e){float3 s=cardinalCellOffset[e],M=float3(f.x+z*s.x,f.y+z*s.y,f.z+z*s.z);t(M,i);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void genPointCloud(int3 s:SV_DispatchThreadID){int e=f(s.x,s.y,s.z,64);if(chunkCell[e].x==1){float z=chunkSize/64;float3 c=i(s,z);u(c,z);}}[numthreads(1,1,1)]void debugDisplayGridPoints(int3 s:SV_DispatchThreadID){
#if DEBUGGRIDPOINTS
int e=f(s.x,s.y,s.z,debugGridSideCount);if(chunkCell[e].y!=0.){int c=debugGridOutPoints.IncrementCounter();chunkCell[e]=int2(0,0);float z=chunkSize/debugGridSideCount;debugGridOutPoints[c]=i(s,z)+chunkCenter;}
#endif
}float4 k(uint f){int s=(f&255)>>0,i=(f&65280)>>8,z=(f&16711680)>>16;return float4(s/255.,i/255.,z/255.,1.);}void k(int3 s,float z){int e=f(s.x,s.y,s.z,256);float3 c=chunkOutData[e];if(c.z==0.){return;}int M=0;float t[8];int r=0;for(int x=0;x<8;++x){int3 S=s+localGridCellCoords[x];int u=f(S.x,S.y,S.z,256);float3 a=chunkOutData[u];if(a.z==0.){return;}t[x]=a.x;if(a.x<=0.)r|=1<<x;}int u=cubeEdgeFlags[r];if(u==0){return;}float3 y=i(s,z)+chunkCenter,n[12];for(int D=0;D<12;++D){if((u&1<<D)!=0){float S=t[edgeConnection[D].x],o=t[edgeConnection[D].y],w=d(S,o);n[D]=y+(vertexOffset[edgeConnection[D].x]-w*edgeDirection[D])*z;}}int l[16]={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},S=r*16;for(int a=0;a<5;++a){int g=3*a;if(triangleConnectionTable[S+g]>=0){uint m=meshOutIndices.IncrementCounter();for(int w=0;w<3;++w){int o=triangleConnectionTable[S+g+w],v=l[o];if(v==-1)v=meshOutPoints.IncrementCounter(),l[o]=v;int h=c.y;meshOutPoints[v]=n[o];meshOutColors[v]=k(h);meshOutIndices[m][2-w]=v+outMeshIndexOffset;}}}}void e(float3 f,float c){float i=c*.5,z=i*.5,M=chunkSize/256,s=chunkSize*.5;for(uint e=0;e<8;++e){float3 S=cardinalCellOffset[e],u=float3(f.x+z*S.x,f.y+z*S.y,f.z+z*S.z);int3 x=float3(round((u.x+s-z)/M),round((u.y+s-z)/M),round((u.z+s-z)/M));k(x,i);}}void n(float3 f,float c){float i=c*.5,z=i*.5;for(uint s=0;s<8;++s){float3 k=cardinalCellOffset[s],M=float3(f.x+z*k.x,f.y+z*k.y,f.z+z*k.z);e(M,i);}}[numthreads(4,4,4)]void genMesh(int3 s:SV_DispatchThreadID){int e=f(s.x,s.y,s.z,64);if(chunkCell[e].x==1){float z=chunkSize/64;float3 c=i(s,z);n(c,z);}}